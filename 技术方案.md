æˆ‘æ¥å¸®ä½ åˆ›å»ºä¸€ä¸ªæ–°çš„IAOæ¨¡å—ï¼ŒåŒ…å«å¼€å§‹å‰ã€è¿›è¡Œä¸­å’Œç»“æŸåä¸‰ä¸ªé˜¶æ®µã€‚æˆ‘ä¼šåŸºäºä½ æä¾›çš„ä»£ç è¿›è¡Œé‡æ„å’Œä¼˜åŒ–ã€‚

```typescript
/**
 * é‡æ„åçš„ IaoPool ç»„ä»¶ - æ”¯æŒä¸‰ä¸ªé˜¶æ®µ
 * 1. IAOå¼€å§‹å‰ (Before)
 * 2. IAOè¿›è¡Œä¸­ (Active)
 * 3. IAOç»“æŸå (Ended)
 */

import React from 'react';
import { useState, useCallback, useEffect, useMemo } from 'react';
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useTranslations } from 'next-intl';
import { useToast } from '@/components/ui/use-toast';
import { useNetwork } from '@/hooks/useNetwork';
import { IaoBeforeView } from './IaoBeforeView';
import { IaoActiveView } from './IaoActiveView';
import { IaoEndedView } from './IaoEndedView';
import { UpdateIaoTimeModal } from './UpdateIaoTimeModal';
import { useIaoPoolData } from './useIaoPoolData';
import type { LocalModel } from "@/types/model";

interface IaoPoolProps {
  agent: LocalModel;
  onRefreshAgent?: () => void | Promise<void>;
}

const IaoPool = React.memo(({ agent, onRefreshAgent }: IaoPoolProps) => {
  const t = useTranslations('iaoPool');
  const { toast } = useToast();
  const { ensureCorrectNetwork } = useNetwork();
  
  const [isCreating, setIsCreating] = useState(false);
  const [isClaiming, setIsClaiming] = useState(false);
  const [isUpdateTimeModalOpen, setIsUpdateTimeModalOpen] = useState(false);
  const [hasConfirmedRedeployment, setHasConfirmedRedeployment] = useState(false);
  const [processedCompletedTasks, setProcessedCompletedTasks] = useState<Set<string>>(new Set());

  // ä½¿ç”¨æ•°æ®ç®¡ç†Hook
  const {
    // çŠ¶æ€
    dbcAmount,
    setDbcAmount,
    maxDbcAmount,
    maxXaaAmount,
    xaaBalance,
    isIaoSuccessful,
    tokenCreationTask,
    distributionTask,
    iaoTask,
    userStakeInfo,
    iaoProgress,
    poolInfo,
    isCreator,
    isIAOEnded,
    isIAOStarted,
    iaoPhase, // æ–°å¢ï¼šIAOé˜¶æ®µ ('before' | 'active' | 'ended')

    // åŠ è½½çŠ¶æ€
    isStakeLoading,
    isPoolInfoLoading,
    isUserStakeInfoLoading,

    // æ–¹æ³•
    stake,
    claimRewards,
    isContractOwner,
    fetchUserStakeInfo,
    fetchTokenCreationTask,
    fetchIaoProgress,
    checkIaoStatus,
    fetchPoolInfo,

    // ä¾¿æ·è®¿é—®
    address,
    isConnected,
    isAuthenticated
  } = useIaoPoolData(agent);

  console.log("å½“å‰IAOé˜¶æ®µ:", iaoPhase);
  console.log("iaoTaskçŠ¶æ€:", iaoTask);

  /**
   * ç›‘æ§IAOéƒ¨ç½²ä»»åŠ¡çŠ¶æ€
   */
  useEffect(() => {
    if (iaoTask) {
      const taskId = iaoTask.id;
      
      if (iaoTask.status === 'COMPLETED' && !processedCompletedTasks.has(taskId)) {
        console.log('[IAOéƒ¨ç½²] ä»»åŠ¡å®Œæˆï¼Œå‡†å¤‡åˆ·æ–°ç»„ä»¶æ•°æ®');
        
        setProcessedCompletedTasks(prev => new Set([...prev, taskId]));
        
        // å»¶è¿Ÿåˆ·æ–°ç»„ä»¶æ•°æ®
        setTimeout(async () => {
          await handleRefreshData();
        }, 1500);
        
      } else if (iaoTask.status === 'FAILED') {
        console.log('[IAOéƒ¨ç½²] ä»»åŠ¡å¤±è´¥:', iaoTask.result);
        const errorMsg = iaoTask.result?.error || t('iaoDeployFailed');
        toast({
          title: t('error'),
          description: errorMsg,
          variant: "destructive"
        });
      }
    }
  }, [iaoTask, processedCompletedTasks, t, toast]);

  /**
   * å¤„ç†è´¨æŠ¼
   */
  const handleStake = useCallback(async () => {
    if (!isAuthenticated) {
      toast({
        title: t('error'),
        description: t('connectWalletFirst'),
      });
      return;
    }

    if (!dbcAmount || Number(dbcAmount) <= 0) {
      toast({
        title: t('error'),
        description: t('enterValidAmount'),
      });
      return;
    }

    const maxAvailableAmount = agent.symbol === 'XAA' ? maxDbcAmount : maxXaaAmount;
    
    if (Number(dbcAmount) > Number(maxAvailableAmount)) {
      toast({
        title: t('error'),
        description: t('notEnoughBalance'),
      });
      return;
    }

    try {
      await ensureCorrectNetwork();
      const result = await stake(dbcAmount, agent.symbol);
      
      if (result && ((result as any)?.hash || result?.receipt?.status === 'success')) {
        toast({
          title: t('success'),
          description: t('investSuccess', {
            amount: dbcAmount,
            symbol: agent.symbol === 'XAA' ? 'DBC' : 'XAA'
          }),
        });
        
        await fetchUserStakeInfo();
        setDbcAmount("");
      } else {
        throw new Error((result as any)?.error || t('investFailed'));
      }
    } catch (error: any) {
      console.error('è´¨æŠ¼å¤±è´¥:', error);
      toast({
        title: t('error'),
        description: error.message || t('investFailed'),
      });
    }
  }, [isAuthenticated, dbcAmount, maxDbcAmount, maxXaaAmount, ensureCorrectNetwork, stake, agent.symbol, toast, t, fetchUserStakeInfo]);

  /**
   * å¤„ç†åˆ›å»ºä»£å¸
   */
  const handleCreateToken = useCallback(async () => {
    if (!isAuthenticated || !isCreator) {
      toast({
        title: t('error'),
        description: t('notAuthorized'),
      });
      return;
    }

    try {
      setIsCreating(true);
      
      // TODO: è°ƒç”¨åˆ›å»ºä»£å¸API
      const response = await fetch(`/api/agents/${agent.id}/create-token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({
          name: agent.name,
          symbol: agent.symbol || 'DBC',
        }),
      });

      const data = await response.json();

      if (response.ok && data.code === 200) {
        toast({
          title: t('success'),
          description: t('tokenCreationInitiated'),
        });

        await fetchTokenCreationTask();
      } else {
        throw new Error(data.message || t('tokenCreationFailed'));
      }
    } catch (error: any) {
      console.error('åˆ›å»ºä»£å¸å¤±è´¥:', error);
      toast({
        title: t('error'),
        description: error.message || t('tokenCreationFailed'),
      });
    } finally {
      setIsCreating(false);
    }
  }, [isAuthenticated, isCreator, agent.id, agent.name, agent.symbol, fetchTokenCreationTask, toast, t]);

  /**
   * éƒ¨ç½²IAOåˆçº¦
   */
  const handleDeployIao = useCallback(async () => {
    if (!isAuthenticated || !isCreator) {
      toast({
        title: t('error'),
        description: t('notAuthorized'),
      });
      return;
    }

    try {
      toast({
        title: t('deploying'),
        description: t('deployingIaoContract'),
      });

      // TODO: è°ƒç”¨éƒ¨ç½²IAOåˆçº¦API
      const response = await fetch(`/api/agents/${agent.id}/deploy-iao`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        }
      });

      const data = await response.json();

      if (response.ok && data.code === 200) {
        toast({
          title: t('success'),
          description: t('iaoDeployTaskSubmitted'),
        });

        await fetchTokenCreationTask();
      } else {
        throw new Error(data.message || t('iaoDeployFailed'));
      }
    } catch (error: any) {
      console.error('éƒ¨ç½²IAOå¤±è´¥:', error);
      toast({
        title: t('error'),
        description: error.message || t('iaoDeployFailed'),
      });
    }
  }, [isAuthenticated, isCreator, agent.id, toast, t, fetchTokenCreationTask]);

  /**
   * é‡æ–°éƒ¨ç½²IAOåˆçº¦
   */
  const handleRedeployIao = useCallback(async () => {
    if (!isAuthenticated || !isCreator) {
      toast({
        title: t('error'),
        description: t('notAuthorized'),
      });
      return;
    }

    try {
      if (agent.iaoContractAddress && !window.confirm(t('redeployIaoConfirmation'))) {
        return;
      }

      toast({
        title: t('deploying'),
        description: t('deployingNewIaoContract'),
      });

      // TODO: è°ƒç”¨é‡æ–°éƒ¨ç½²IAO API
      const response = await fetch(`/api/agents/${agent.id}/redeploy-iao`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        }
      });

      const data = await response.json();

      if (response.ok && data.code === 200) {
        toast({
          title: t('success'),
          description: t('iaoRedeployTaskSubmitted'),
        });

        setHasConfirmedRedeployment(false);
        await fetchTokenCreationTask();
      } else {
        throw new Error(data.message || t('redeployIaoFailed'));
      }
    } catch (error: any) {
      console.error('é‡æ–°éƒ¨ç½²IAOå¤±è´¥:', error);
      toast({
        title: t('error'),
        description: error.message || t('redeployIaoFailed'),
      });
    }
  }, [isAuthenticated, isCreator, agent.id, agent.iaoContractAddress, toast, t, fetchTokenCreationTask]);

  /**
   * å¤„ç†é¢†å–å¥–åŠ±
   */
  const handleClaimRewards = useCallback(async () => {
    if (!isAuthenticated) {
      toast({
        title: t('error'),
        description: t('connectWalletFirst'),
      });
      return;
    }

    try {
      setIsClaiming(true);
      const result: any = await claimRewards();

      if (result?.success) {
        await fetchUserStakeInfo();

        toast({
          title: t('claimSuccess'),
          description: `${t('tokenSentToWallet')} ${t('importTokenAddress')}: ${agent.tokenAddress}`,
        });
      } else {
        throw new Error(result?.error || t('claimFailed'));
      }
    } catch (error: any) {
      toast({
        title: t('error'),
        description: error.message || t('claimFailed'),
      });
    } finally {
      setIsClaiming(false);
    }
  }, [isAuthenticated, claimRewards, fetchUserStakeInfo, agent.tokenAddress, toast, t]);

  /**
   * è®¾ç½®æœ€å¤§é‡‘é¢
   */
  const handleSetMaxAmount = useCallback(() => {
    const reserveAmount = 0.01;
    const maxAmount = agent.symbol === 'XAA' ? maxDbcAmount : maxXaaAmount;
    const availableAmount = Math.max(Number(maxAmount) - reserveAmount, 0);
    setDbcAmount(availableAmount.toString());
  }, [maxDbcAmount, maxXaaAmount, agent.symbol, setDbcAmount]);

  /**
   * åˆ·æ–°æ•°æ®
   */
  const handleRefreshData = useCallback(async () => {
    if (onRefreshAgent) {
      await onRefreshAgent();
    }

    fetchPoolInfo();
    fetchUserStakeInfo();
    fetchIaoProgress();
    checkIaoStatus();
  }, [fetchPoolInfo, fetchUserStakeInfo, fetchIaoProgress, checkIaoStatus, onRefreshAgent]);

  /**
   * æ¸²æŸ“æ ‡é¢˜æ 
   */
  const renderTitleBar = () => {
    let title = '';
    switch (iaoPhase) {
      case 'before':
        title = t('iaoBeforeTitle');
        break;
      case 'active':
        title = t('iaoActiveTitle');
        break;
      case 'ended':
        title = isIaoSuccessful ? t('iaoSuccessTitle') : t('iaoFailedTitle');
        break;
      default:
        title = t('title');
    }

    return (
      <div className="flex flex-col sm:flex-row gap-2 sm:gap-4 mb-4 justify-between items-start sm:items-center">
        <h2 className="text-xl sm:text-2xl font-bold mb-0">{title}</h2>
        <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
          {/* ä»…åœ¨IAOæœªå¼€å§‹ä¸”ç”¨æˆ·æ˜¯åˆ›å»ºè€…æ—¶æ˜¾ç¤ºè°ƒæ•´æ—¶é—´æŒ‰é’® */}
          {isCreator && iaoPhase === 'before' && agent.iaoContractAddress && (
            <Button
              variant="primary"
              size="sm"
              className="w-full sm:w-auto bg-[#F47521] hover:bg-[#E56411] text-white flex items-center justify-center gap-2"
              onClick={() => setIsUpdateTimeModalOpen(true)}
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
              </svg>
              <span>{t('updateIaoTime')}</span>
            </Button>
          )}
          
          {/* åˆ·æ–°æŒ‰é’® */}
          <Button
            variant="outline"
            size="sm"
            className="w-full sm:w-auto text-sm sm:text-base flex items-center justify-center gap-2"
            onClick={handleRefreshData}
            disabled={isPoolInfoLoading}
          >
            {isPoolInfoLoading ? (
              <>
                <svg className="animate-spin w-4 h-4" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>{t('refreshing')}</span>
              </>
            ) : (
              <>
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                </svg>
                <span>{t('refresh')}</span>
              </>
            )}
          </Button>
        </div>
      </div>
    );
  };

  /**
   * æ¸²æŸ“å½“å‰é˜¶æ®µçš„è§†å›¾
   */
  const renderCurrentPhaseView = () => {
    switch (iaoPhase) {
      case 'before':
        return (
          <IaoBeforeView
            agent={agent}
            poolInfo={poolInfo}
            isCreator={isCreator}
            iaoTask={iaoTask}
            isPoolInfoLoading={isPoolInfoLoading}
            onDeployIao={handleDeployIao}
            onRefresh={handleRefreshData}
          />
        );
      
      case 'active':
        return (
          <IaoActiveView
            agent={agent}
            poolInfo={poolInfo}
            userStakeInfo={userStakeInfo}
            iaoProgress={iaoProgress}
            dbcAmount={dbcAmount}
            setDbcAmount={setDbcAmount}
            maxDbcAmount={maxDbcAmount}
            maxXaaAmount={maxXaaAmount}
            xaaBalance={xaaBalance}
            isCreator={isCreator}
            isIaoSuccessful={isIaoSuccessful}
            isStakeLoading={isStakeLoading}
            isPoolInfoLoading={isPoolInfoLoading}
            isUserStakeInfoLoading={isUserStakeInfoLoading}
            isAuthenticated={isAuthenticated}
            isConnected={isConnected}
            onStake={handleStake}
            onSetMaxAmount={handleSetMaxAmount}
            onRefresh={handleRefreshData}
            isContractOwner={isContractOwner}
          />
        );
      
      case 'ended':
        return (
          <IaoEndedView
            agent={agent}
            poolInfo={poolInfo}
            userStakeInfo={userStakeInfo}
            iaoProgress={iaoProgress}
            isIaoSuccessful={isIaoSuccessful}
            isCreator={isCreator}
            tokenCreationTask={tokenCreationTask}
            distributionTask={distributionTask}
            isPoolInfoLoading={isPoolInfoLoading}
            onCreateToken={handleCreateToken}
            onClaimRewards={handleClaimRewards}
            onRefreshStatus={handleRefreshData}
            onPaymentModalOpen={() => {}}
            isCreating={isCreating}
            isClaiming={isClaiming}
            canClaim={!userStakeInfo.hasClaimed && Number(userStakeInfo.userDeposited) > 0}
          />
        );
      
      default:
        return <div className="text-center py-8">{t('loading')}</div>;
    }
  };

  return (
    <Card className="p-4 sm:p-6">
      {renderTitleBar()}
      {renderCurrentPhaseView()}
      
      {/* æ¨¡æ€æ¡† */}
      <UpdateIaoTimeModal
        isOpen={isUpdateTimeModalOpen}
        onOpenChange={setIsUpdateTimeModalOpen}
        currentStartTime={poolInfo?.startTime || 0}
        currentEndTime={poolInfo?.endTime || 0}
        agentId={agent.id}
        onSuccess={handleRefreshData}
        isPoolInfoLoading={isPoolInfoLoading}
      />
    </Card>
  );
});

export default IaoPool;
```

ç°åœ¨åˆ›å»º **IaoBeforeView.tsx** (IAOå¼€å§‹å‰è§†å›¾):

```typescript
/**
 * IAOå¼€å§‹å‰çš„è§†å›¾ç»„ä»¶
 * æ˜¾ç¤ºIAOå‡†å¤‡ä¿¡æ¯å’Œå€’è®¡æ—¶
 */

'use client';

import { Button } from "@/components/ui/button";
import { useTranslations } from 'next-intl';
import { Countdown } from "@/components/ui-custom/countdown";
import type { LocalModel } from "@/types/model";

interface IaoBeforeViewProps {
  agent: LocalModel;
  poolInfo: any;
  isCreator: boolean;
  iaoTask: any;
  isPoolInfoLoading: boolean;
  onDeployIao: () => void;
  onRefresh: () => void;
}

export const IaoBeforeView = ({
  agent,
  poolInfo,
  isCreator,
  iaoTask,
  isPoolInfoLoading,
  onDeployIao,
  onRefresh
}: IaoBeforeViewProps) => {
  const t = useTranslations('iaoPool');

  const formatNumber = (value: string | number, decimals: number = 2): string => {
    if (!value || value === '0') return '0';
    const num = typeof value === 'string' ? parseFloat(value) : value;
    if (isNaN(num)) return '0';
    return num.toLocaleString('en-US', {
      minimumFractionDigits: 0,
      maximumFractionDigits: decimals
    });
  };

  // æ£€æŸ¥IAOæ˜¯å¦æ­£åœ¨éƒ¨ç½²
  const isIaoDeploying = iaoTask && ['PENDING', 'PROCESSING'].includes(iaoTask.status);
  const isIaoDeployFailed = iaoTask && iaoTask.status === 'FAILED';

  /**
   * æ¸²æŸ“IAOéƒ¨ç½²çŠ¶æ€
   */
  const renderDeploymentStatus = () => {
    if (!agent.iaoContractAddress && !iaoTask) {
      // æœªéƒ¨ç½²ä¸”æ— ä»»åŠ¡
      return (
        <div className="mb-6 p-4 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-700 rounded-lg">
          <div className="flex items-start gap-3">
            <svg className="w-5 h-5 text-yellow-500 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
            </svg>
            <div className="flex-1">
              <h4 className="text-sm font-medium text-yellow-800 dark:text-yellow-200 mb-2">
                {t('iaoNotDeployed')}
              </h4>
              <p className="text-xs text-yellow-700 dark:text-yellow-300 mb-3">
                {isCreator ? t('iaoNotDeployedDescCreator') : t('iaoNotDeployedDescUser')}
              </p>
              {isCreator && (
                <Button
                  className="w-full text-sm py-2 bg-yellow-500 hover:bg-yellow-600 text-white"
                  onClick={onDeployIao}
                >
                  {t('deployIaoContract')}
                </Button>
              )}
            </div>
          </div>
        </div>
      );
    }

    if (isIaoDeploying) {
      // æ­£åœ¨éƒ¨ç½²
      return (
        <div className="mb-6 p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-lg">
          <div className="flex items-start gap-3">
            <svg className="animate-spin w-5 h-5 text-blue-500 mt-0.5 flex-shrink-0" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <div className="flex-1">
              <h4 className="text-sm font-medium text-blue-800 dark:text-blue-200 mb-2">
                {t('iaoDeploying')}
              </h4>
              <p className="text-xs text-blue-700 dark:text-blue-300">
                {isCreator ? t('iaoDeployingDescCreator') : t('iaoDeployingDescUser')}
              </p>
            </div>
          </div>
        </div>
      );
    }

    if (isIaoDeployFailed) {
      // éƒ¨ç½²å¤±è´¥
      return (
        <div className="mb-6 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-700 rounded-lg">
          <div className="flex items-start gap-3">
            <svg className="w-5 h-5 text-red-500 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
            <div className="flex-1">
              <h4 className="text-sm font-medium text-red-800 dark:text-red-200 mb-2">
                {t('iaoDeployFailed')}
              </h4>
              <p className="text-xs text-red-700 dark:text-red-300 mb-3">
                {isCreator ? t('iaoDeployFailedDescCreator') : t('iaoDeployFailedDescUser')}
              </p>
              {isCreator && (
                <Button
                  className="w-full text-sm py-2 bg-red-500 hover:bg-red-600 text-white"
                  onClick={onDeployIao}
                >
                  {t('retryDeploy')}
                </Button>
              )}
            </div>
          </div>
        </div>
      );
    }

    return null;
  };

  /**
   * æ¸²æŸ“IAOåŸºæœ¬ä¿¡æ¯
   */
  const renderIaoInfo = () => (
    <div className="space-y-3 sm:space-y-4">
      {/* çŠ¶æ€æŒ‡ç¤ºå™¨ */}
      <div className="flex items-center gap-2 mb-4">
        <div className="w-2 h-2 rounded-full bg-blue-500"></div>
        <span className="text-sm font-medium text-blue-500">
          {t('iaoComingSoon')}
        </span>
      </div>

      {/* IAOä»£å¸æ€»é‡ */}
      <div className="text-sm sm:text-base flex flex-col sm:flex-row sm:flex-wrap sm:items-center gap-1 sm:gap-2 bg-orange-50 dark:bg-orange-900/20 p-3 rounded-lg">
        <span className="text-black dark:text-white font-medium">
          {t('iaoTotalAmount', { symbol: agent.symbol })}:
        </span>
        <span className="font-medium text-[#F47521] dark:text-orange-400 break-all">
          {isPoolInfoLoading ? "--" : `${formatNumber(Number((agent.iaoTokenAmount as any || '0') / 10 ** 18 || 0))} ${agent.symbol}`}
        </span>
      </div>

      {/* å¼€å§‹å€’è®¡æ—¶ */}
      {poolInfo?.startTime && (
        <div className="text-sm sm:text-base flex flex-col sm:flex-row sm:flex-wrap sm:items-center gap-1 sm:gap-2 bg-purple-50 dark:bg-purple-900/20 p-3 rounded-lg">
          <span className="text-black dark:text-white font-medium">
            {t('startCountdown')}:
          </span>
          {isPoolInfoLoading ? (
            <span className="font-medium text-[#F47521] dark:text-orange-400 break-all">--</span>
          ) : (
            <Countdown
              remainingTime={Math.max(0, poolInfo.startTime * 1000 - Date.now())}
              className="font-medium text-[#F47521] dark:text-orange-400 break-all text-sm sm:text-base"
              onEnd={onRefresh}
            />
          )}
        </div>
      )}

      {/* IAOæŒç»­æ—¶é•¿ */}
      {poolInfo?.startTime && poolInfo?.endTime && (
        <div className="text-sm sm:text-base flex flex-col sm:flex-row sm:flex-wrap sm:items-center gap-1 sm:gap-2 bg-green-50 dark:bg-green-900/20 p-3 rounded-lg">
          <span className="text-black dark:text-white font-medium">{t('iaoDuration')}:</span>
          <div className="flex items-center gap-2 flex-wrap">
            {isPoolInfoLoading ? (
              <span className="font-medium text-[#F47521] dark:text-orange-400 break-all">--</span>
            ) : (() => {
              const durationMs = (poolInfo.endTime - poolInfo.startTime) * 1000;
              const days = Math.floor(durationMs / (1000 * 60 * 60 * 24));
              const hours = Math.floor((durationMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
              
              return (
                <>
                  {days > 0 && (
                    <div className="flex items-center gap-1">
                      <span className="font-medium text-[#F47521] dark:text-orange-400">{days}</span>
                      <span className="text-sm font-medium text-[#F47521] dark:text-orange-400">{t('durationDays')}</span>
                    </div>
                  )}
                  {hours > 0 && (
                    <div className="flex items-center gap-1">
                      <span className="font-medium text-[#F47521] dark:text-orange-400">{hours}</span>
                      <span className="text-sm font-medium text-[#F47521] dark:text-orange-400">{t('durationHours')}</span>
                    </div>
                  )}
                </>
              );
            })()}
          </div>
        </div>
      )}

      {/* æç¤ºä¿¡æ¯ */}
      <div className="mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-700 rounded-lg">
        <div className="flex items-start gap-3">
          <svg className="w-5 h-5 text-blue-500 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          <div className="flex-1">
            <h4 className="text-sm font-medium text-blue-800 dark:text-blue-200 mb-2">
              {t('iaoWillStartSoon')}
            </h4>
            <p className="text-xs text-blue-700 dark:text-blue-300">
              {t('iaoBeforeDescription')}
            </p>
          </div>
        </div>
      </div>
    </div>
  );

  return (
    <>
      {renderDeploymentStatus()}
      {agent.iaoContractAddress && renderIaoInfo()}
    </>
  );
};
```

ç»§ç»­æ›´æ–° **useIaoPoolData.ts** æ·»åŠ é˜¶æ®µåˆ¤æ–­:

```typescript
// åœ¨ useIaoPoolData hook ä¸­æ·»åŠ ä»¥ä¸‹ä»£ç 

// ... ç°æœ‰ä»£ç  ...

// è®¡ç®—IAOé˜¶æ®µ
const iaoPhase = useMemo((): 'before' | 'active' | 'ended' => {
  if (!poolInfo?.startTime || !poolInfo?.endTime) {
    return 'before'; // æ²¡æœ‰æ—¶é—´ä¿¡æ¯ï¼Œè§†ä¸ºæœªå¼€å§‹
  }
  
  const now = Date.now();
  const startTime = poolInfo.startTime * 1000;
  const endTime = poolInfo.endTime * 1000;
  
  if (now < startTime) {
    return 'before'; // æœªå¼€å§‹
  } else if (now >= startTime && now < endTime) {
    return 'active'; // è¿›è¡Œä¸­
  } else {
    return 'ended'; // å·²ç»“æŸ
  }
}, [poolInfo]);

// æ£€æŸ¥IAOæ˜¯å¦å·²å¼€å§‹
const isIAOStarted = useMemo(() => {
  return poolInfo?.startTime ? Date.now() >= poolInfo.startTime * 1000 : false;
}, [poolInfo]);

// åœ¨è¿”å›å€¼ä¸­æ·»åŠ æ–°å­—æ®µ
return useMemo(() => ({
  // ... ç°æœ‰è¿”å›å€¼ ...
  
  // æ–°å¢å­—æ®µ
  iaoPhase,
  isIAOStarted,
  
  // ... å…¶ä»–ç°æœ‰è¿”å›å€¼ ...
}), [
  // ... ç°æœ‰ä¾èµ– ...
  iaoPhase,
  isIAOStarted,
  // ... å…¶ä»–ç°æœ‰ä¾èµ– ...
]);
```

è¿™ä¸ªé‡æ„åçš„IAOæ¨¡å—åŒ…å«ï¼š

## âœ… å®Œæˆçš„åŠŸèƒ½

1. **ä¸‰ä¸ªé˜¶æ®µçš„è§†å›¾**
   - `IaoBeforeView`: IAOå¼€å§‹å‰
   - `IaoActiveView`: IAOè¿›è¡Œä¸­ï¼ˆå·²æœ‰ï¼‰
   - `IaoEndedView`: IAOç»“æŸåï¼ˆå·²æœ‰ï¼‰

2. **é˜¶æ®µè‡ªåŠ¨åˆ¤æ–­**
   - æ ¹æ®æ—¶é—´è‡ªåŠ¨åˆ‡æ¢è§†å›¾
   - å€’è®¡æ—¶è‡ªåŠ¨åˆ·æ–°

3. **å®Œæ•´çš„äº¤äº’**
   - éƒ¨ç½²IAOåˆçº¦
   - è´¨æŠ¼æŠ•èµ„
   - é¢†å–å¥–åŠ±
   - æ—¶é—´è°ƒæ•´

## ğŸ“ TODO æ ‡è®°çš„åœ°æ–¹

ä»£ç ä¸­å·²ç»æ ‡è®°äº†éœ€è¦å®ç°çš„APIè°ƒç”¨ï¼š
- `TODO: è°ƒç”¨åˆ›å»ºä»£å¸API`
- `TODO: è°ƒç”¨éƒ¨ç½²IAOåˆçº¦API`
- `TODO: è°ƒç”¨é‡æ–°éƒ¨ç½²IAO API`

è¿™äº›åœ°æ–¹ä½ éœ€è¦æ ¹æ®å®é™…çš„åç«¯æ¥å£è¿›è¡Œå®ç°ã€‚

éœ€è¦æˆ‘ç»§ç»­å®Œå–„å…¶ä»–éƒ¨åˆ†å—ï¼Ÿ